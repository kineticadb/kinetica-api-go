{
    "endpoint": "/create/table/external",
    "type": "record",
    "name": "create_table_external_request",
    "desc_name": "Create External Table",
    "on_prem_only": false,
    "is_host_manager_endpoint": false,
    "is_single_table_oriented": false,
    "short_doc": "Create a new external table",
    "doc": "Creates a new {external table}@{link /concepts/external_tables/}, which is a
local database object whose source data is located externally to the database.  The source data can
be located either on the cluster, accessible to the database; or remotely, accessible via a
pre-defined external {data source}@{link /concepts/data_sources/}.

The external table can have its structure defined explicitly, via @{input create_table_options},
which contains many of the options from @{endpoint /create/table}; or defined implicitly, inferred
from the source data.",
    "fields": [
        {
            "name": "table_name",
            "type": "string",
            "doc": "Name of the table to be created, in [schema_name.]table_name format, using
standard {name resolution rules}@{link /concepts/tables/#table-name-resolution} and meeting
{table naming criteria}@{link /concepts/tables/#table-naming-criteria}.",
            "value": {}
        },
        {
            "name": "filepaths",
            "type":
            {
                "type": "array",
                "items": "string"
            },
            "doc": "A list of file paths from which data will be sourced; wildcards (*) can be used
to specify a group of files.

For paths in KiFS, use the uri prefix of kifs:// followed by the full path to a file or directory.

If an external data source is specified in {datasource_name}@{key of input options}, these file
paths must resolve to accessible files at that data source location. Also, wildcards will only work
when used within the file name, not the path.

If no data source is specified, the files are assumed to be local to the database and must all be
accessible to the gpudb user, residing on the path (or relative to the path) specified by the
external files directory in the Kinetica
{configuration file}@{link /config/#external-files}.",
            "value": {}
        },
        {
            "name": "modify_columns",

            "doc": "Not implemented yet",
            "type":
            {
                "type": "map",
        		"values":
                {
                    "type" : "map",
                    "values" : "string"
                }
            },
            "value":
            {
                "default" : {}
            }

        },
        {
            "name": "create_table_options",
            "type":
            {
                "type": "map",
                "values": "string"
            },
            "doc": "Options from @{endpoint /create/table}, allowing the structure of the table to
be defined independently of the data source",
            "value":
            {
                "default": {},
                "valid_keys":
                {
                    "type_id":
                    {
                        "doc": "ID of a currently registered {type}@{link /concepts/types/}.",
                        "value":
                        {
                            "default": ""
                        }
                    },
                    "no_error_if_exists" :
                    {
                        "doc" : "If {true}@{choice of input.key create_table_options.no_error_if_exists},
prevents an error from occurring if the table already exists and is of the given type.  If a table with
the same name but a different type exists, it is still an error.",
                        "value" :
                        {
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "is_replicated" :
                    {
                        "doc" : "Affects the {distribution scheme}@{link /concepts/tables/#distribution}
for the table's data.  If {true}@{choice of input.key create_table_options.is_replicated} and the
given table has no explicit {shard key}@{link /concepts/tables/#shard-key} defined, the
table will be {replicated}@{link /concepts/tables/#replication}.  If
{false}@{choice of input.key create_table_options.is_replicated}, the table will be
{sharded}@{link /concepts/tables/#sharding} according to the shard key specified in the
given {type_id}@{key of input create_table_options}, or
{randomly sharded}@{link /concepts/tables/#random-sharding}, if no shard key is specified.
Note that a type containing a shard key cannot be used to create a replicated table.",
                        "value":
                        {
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "foreign_keys" :
                    {
                        "doc" : "Semicolon-separated list of
{foreign keys}@{link /concepts/tables/#foreign-keys}, of the format
'(source_column_name [, ...]) references target_table_name(primary_key_column_name [, ...]) [as foreign_key_name]'.",
                        "value": {}
                    },
                    "foreign_shard_key" :
                    {
                        "doc" : "Foreign shard key of the format
'source_column references shard_by_column from target_table(primary_key_column)'.",
                        "value": {}
                    },
                    "partition_type" :
                    {
                        "doc" : "{Partitioning}@{link /concepts/tables/#partitioning} scheme to use.",
                        "value":
                        {
                            "valid_choices" :
                            {
                                "RANGE" :
                                {
                                    "doc" : "Use {range partitioning}@{link /concepts/tables/#partitioning-by-range}.",
                                    "value" : {}
                                },
                                "INTERVAL" :
                                {
                                    "doc" : "Use {interval partitioning}@{link /concepts/tables/#partitioning-by-interval}.",
                                    "value" : {}
                                },
                                "LIST" :
                                {
                                    "doc" : "Use {list partitioning}@{link /concepts/tables/#partitioning-by-list}.",
                                    "value" : {}
                                },
                                "HASH" :
                                {
                                    "doc" : "Use {hash partitioning}@{link /concepts/tables/#partitioning-by-hash}.",
                                    "value" : {}
                                },
                                "SERIES" :
                                {
                                    "doc" : "Use {series partitioning}@{link /concepts/tables/#partitioning-by-series}.",
                                    "value" : {}
                                }
                            }
                        }
                    },
                    "partition_keys" :
                    {
                        "doc" : "Comma-separated list of partition keys, which are the columns or
column expressions by which records will be assigned to partitions defined by
{partition_definitions}@{key of input create_table_options}.",
                        "value": {}
                    },
                    "partition_definitions" :
                    {
                        "doc" : "Comma-separated list of partition definitions, whose format depends
on the choice of {partition_type}@{key of input create_table_options}.  See
{range partitioning}@{link /concepts/tables/#partitioning-by-range},
{interval partitioning}@{link /concepts/tables/#partitioning-by-interval},
{list partitioning}@{link /concepts/tables/#partitioning-by-list},
{hash partitioning}@{link /concepts/tables/#partitioning-by-hash}, or
{series partitioning}@{link /concepts/tables/#partitioning-by-series} for example formats.",
                        "value": {}
                    },
                    "is_automatic_partition" :
                    {
                        "doc" : "If {true}@{choice of input.key create_table_options.is_automatic_partition},
a new partition will be created for values which don't fall into an existing partition.  Currently
only supported for {list partitions}@{link /concepts/tables/#partitioning-by-list}.",
                        "value" :
                        {
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default" : "false"
                        }
                    },
                    "ttl" :
                    {
                        "doc" : "Sets the {TTL}@{link /concepts/ttl/} of the table specified in @{input table_name}.",
                        "value" : {}
                    },
                    "chunk_size" :
                    {
                        "doc"  : "Indicates the number of records per chunk to be used for this table.",
                        "value" : {}
                    },
                    "chunk_column_max_memory" :
                    {
                        "doc"  : "Indicates the target maximum data size for each column in a chunk to be used for this table.",
                        "value" : {}
                    },
                    "is_result_table" :
                    {
                        "doc" : "Indicates whether the table is a
{memory-only table}@{link /concepts/tables_memory_only/}. A result table cannot contain
columns with store_only or text_search
{data-handling}@{link /concepts/types/#data-handling} or that are
{non-charN strings}@{link /concepts/types/#primitive-types}, and it will not be retained if
the server is restarted.",
                        "value" :
                        {
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "strategy_definition":
                    {
                        "doc" : "The {tier strategy}@{link /rm/concepts/#tier-strategies}
for the table and its columns.",
                        "value": {}
                    },
                    "avro_type" :
                    {
                        "doc" : "<DEVELOPER>",
                        "value" :
                        {
                            "internal_option": true,
                            "default": "is_table",
                            "valid_choices" :
                            {
                                "is_table" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_join" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_view" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_other_view" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_projection" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_union" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_unique" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_unpivot" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_merge" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_group_by" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_area" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_area_geometry" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_box_geometry" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_box" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_geometry" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_list" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_radius" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_radius_geometry" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_range" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_series" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_series_values" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_string" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_table" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_filter_by_value" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_update_records_by_series" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_create_view" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_external_table" :
                                {
                                    "doc": "",
                                    "value": {}
                                },
                                "is_create_sql_proc" :
                                {
                                    "doc": "",
                                    "value": {}
                                }
                            }
                        }
                    },
                    "avro_json":
                    {
                        "doc" : "<DEVELOPER>",
                        "value" :
                        {
                            "internal_option": true
                        }
                    },
                    "view_id":
                    {
                        "doc" : "<DEVELOPER>",
                        "value" :
                        {
                            "internal_option": true
                        }
                    },
                    "internal_token" :
                    {
                        "doc" : "<DEVELOPER>",
                        "value" :
                        {
                            "internal_option": true
                        }
                    }
                }

            }
        },
        {
            "name": "options",
            "type":
            {
                "type": "map",
                "values": "string"
            },
            "doc": "Optional parameters.",
            "value":
            {
                "default": {},
                "valid_keys":
                {
                    "bad_record_table_name" :
                    {
                        "doc" : "Optional name of a table to which records that were rejected are written.  The bad-record-table has the following columns: line_number (long), line_rejected (string), error_message (string).",
                        "default": "",
                        "value": {}
                    },
                    "bad_record_table_limit" :
                    {
                        "doc" : "A positive integer indicating the maximum number of records that can be  written to the bad-record-table.   Default value is 10000",
                        "default": "10000",
                        "value": {}
                    },
                    "batch_size":
                    {
                        "doc": "Internal tuning parameter--number of records per batch when inserting data",
                        "default": "200000",
                        "value":{}
                    },
                    "column_formats" :
                    {
                        "doc" : "For each target column specified, applies the column-property-bound
format to the source data loaded into that column.  Each column format will contain a mapping of one
or more of its column properties to an appropriate format for each property.  Currently supported
column properties include date, time, & datetime. The parameter value must be formatted as a JSON
string of maps of column names to maps of column properties to their corresponding column formats,
e.g.,
'{ \"order_date\" : { \"date\" : \"%Y.%m.%d\" }, \"order_time\" : { \"time\" : \"%H:%M:%S\" } }'.

See {default_column_formats}@{key of input options} for valid format syntax.",
                        "value": {}
                    },
                    "columns_to_load":
                    {
                        "doc": "Specifies a comma-delimited list of columns from the source data to
load.  If more than one file is being loaded, this list applies to all files.

Column numbers can be specified discretely or as a range.  For example, a value of '5,7,1..3' will
insert values from the fifth column in the source data into the first column in the target table,
from the seventh column in the source data into the second column in the target table, and from the
first through third columns in the source data into the third through fifth columns in the target
table.

If the source data contains a header, column names matching the file header names may be provided
instead of column numbers.  If the target table doesn't exist, the table will be created with the
columns in this order.  If the target table does exist with columns in a different order than the
source data, this list can be used to match the order of the target table.  For example, a value of
'C, B, A' will create a three column table with column C, followed by column B, followed by column
A; or will insert those fields in that order into a table created with columns in that order.  If
the target table exists, the column names must match the source data field names for a name-mapping
to be successful.",
                        "value": {}
                    },
                    "columns_to_skip":
                    {
                        "doc": "Specifies a comma-delimited list of columns from the source data to
skip.  Mutually exclusive to columns_to_load. ",
                        "value": {}
                    },
                    "datasource_name":
                    {
                        "doc":"Name of an existing external data source from which data file(s) specified in @{input filepaths} will be loaded",
                        "value": {}
                    },
                    "default_column_formats" :
                    {
                        "doc": "Specifies the default format to be applied to source data loaded
into columns with the corresponding column property.  Currently supported column properties include
date, time, & datetime.  This default column-property-bound format can be overridden by specifying a
column property & format for a given target column in {column_formats}@{key of input options}. For
each specified annotation, the format will apply to all columns with that annotation unless a custom
{column_formats}@{key of input options} for that annotation is specified.

The parameter value must be formatted as a JSON string that is a map of column properties to their
respective column formats, e.g., '{ \"date\" : \"%Y.%m.%d\", \"time\" : \"%H:%M:%S\" }'.  Column
formats are specified as a string of control characters and plain text. The supported control
characters are 'Y', 'm', 'd', 'H', 'M', 'S', and 's', which follow the Linux 'strptime()'
specification, as well as 's', which specifies seconds and fractional seconds (though the fractional
component will be truncated past milliseconds).

Formats for the 'date' annotation must include the 'Y', 'm', and 'd' control characters. Formats for
the 'time' annotation must include the 'H', 'M', and either 'S' or 's' (but not both) control
characters. Formats for the 'datetime' annotation meet both the 'date' and 'time' control character
requirements. For example, '{\"datetime\" : \"%m/%d/%Y %H:%M:%S\" }' would be used to interpret text
as \"05/04/2000 12:12:11\"",
                        "value": {}
                    },
                    "error_handling":
                    {
                        "doc": "Specifies how errors should be handled upon insertion.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "permissive":
                                {
                                    "doc": "Records with missing columns are populated with nulls if possible; otherwise, malformed records are skipped.",
                                    "value": {}
                                },
                                "ignore_bad_records":
                                {
                                    "doc": "Malformed records are skipped.",
                                    "value": {}
                                },
                                "abort":
                                {
                                    "doc": "Current insertion is stopped and entire operation is aborted when an error is encountered.  Primary key collisions are considered abortable errors in this mode.",
                                    "value": {}
                                }
                            },
                            "default": "permissive"
                        }
                    },
                    "external_table_type":
                    {
                        "doc": "Specifies whether the external table holds a local copy of the external data.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "materialized":
                                {
                                    "doc": "Loads a copy of the external data into the database, refreshed on demand",
                                    "value": {}
                                },
                                "logical":
                                {
                                    "doc": "External data will not be loaded into the database; the data will be retrieved from the source upon servicing each query against the external table",
                                    "value": {}
                                }
                            },
                            "default": "materialized"
                        }
                    },
                    "file_type":
                    {
                        "doc": "Specifies the type of the external data file(s) used as the source of data for this table.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "delimited_text":
                                {
                                    "doc": "Delimited text file format; e.g., CSV, TSV, PSV, etc.",
                                    "value": {}
                                },
                                "parquet":
                                {
                                    "doc": "Apache Parquet file format",
                                    "value": {}
                                },
                                "json":
                                {
                                    "doc": "Json file format",
                                    "value": {}
                                },
                                "shapefile":
                                {
                                    "doc": "ShapeFile file format",
                                    "value": {}
                                }
                            },
                            "default": "delimited_text"
                        }
                    },
                    "ingestion_mode":
                    {
                        "doc": "For {materialized}@{choice of input.key options.external_table_type} external tables, whether to do a full load, dry run, or perform a type inference on the source data.",
                        "value":
                        {
                            "default": "full",
                            "valid_choices":
                            {
                                "full" :
                                {
                                    "doc": "Run a type inference on the source data (if needed) and ingest",
                                    "value" : {}
                                },
                                "dry_run" :
                                {
                                    "doc" : "Does not load data, but walks through the source data and determines the number of valid records, taking into account the current mode of {error_handling}@{key of input options}.",
                                    "value" : {}
                                },
                                "type_inference_only" :
                                {
                                    "doc": "Infer the type of the source data and return, without creating the table and ingesting data.  The inferred type is returned in the response.",
                                    "value" : {}
                                }
                            }
                        }
                    },
                    "loading_mode":
                    {
                        "doc": "Scheme for distributing the extraction and loading of data from the source data file(s).",
                        "value":
                        {
                            "valid_choices":
                            {
                                "head":
                                {
                                    "doc": "The head node loads all data. All files must be available to the head node.",
                                    "value": {}
                                },
                                "distributed_shared":
                                {
                                    "doc": "The head node coordinates loading data by worker
processes across all nodes from shared files available to all workers.

NOTE:

Instead of existing on a shared source, the files can be duplicated on a source local to each host
to improve performance, though the files must appear as the same data set from the perspective of
all hosts performing the load.",
                                    "value": {}
                                },
                                "distributed_local":
                                {
                                    "doc": "A single worker process on each node loads all files
that are available to it. This option works best when each worker loads files from its own file
system, to maximize performance. In order to avoid data duplication, either each worker performing
the load needs to have visibility to a set of files unique to it (no file is visible to more than
one node) or the target table needs to have a primary key (which will allow the worker to
automatically deduplicate data).

NOTE:

If the table's columns aren't defined, table structure will be determined by the head node. If the
head node has no files local to it, it will be unable to determine the structure and the request
will fail.

This mode should not be used in conjunction with a data source, as data sources are seen by all
worker processes as shared resources with no 'local' component.

If the head node is configured to have no worker processes, no data strictly accessible to the head
node will be loaded.",
                                    "value": {}
                                }
                            },
                            "default": "head"
                        }
                    },
                    "primary_keys":
                    {
                        "doc": "Optional: comma separated list of column names, to set as primary keys, when not specified in the type.",
                        "value": {
                            "default": ""
                        }
                    },
                    "shard_keys":
                    {
                        "doc": "Optional: comma separated list of column names, to set as primary keys, when not specified in the type.",
                        "value": {
                            "default": ""
                        }
                    },
                    "test_head_loading_mode":
                    {
                        "doc": "When true rank0 loads all data. Same as loading_mode = head when no worker ranks are on same processor as rank0.",
                        "value" :
                        {
                            "internal_option": true
                        }
                    },
                    "refresh_method" :
                    {
                        "doc": "Method by which the table can be refreshed from its source data.",
                        "value" :
                        {
                            "default" : "manual",
                            "valid_choices" :
                            {
                                "manual" :
                                {
                                    "doc": "Refresh only occurs when manually requested by invoking the refresh action of @{endpoint /alter/table} on this table.",
                                    "value" : {}
                                },
                                "on_start" :
                                {
                                    "doc":  "Refresh table on database startup and when manually requested by invoking the refresh action of @{endpoint /alter/table} on this table.",
                                    "value" : {}
                                }
                            }
                        }
                    },
                    "subscribe":
                    {
                        "doc": "Continuously poll the data source to check for new data and load it into the table.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "poll_interval":
                    {
                        "doc": "If {true}@{choice of input.key options.subscribe}, the number of seconds between attempts to load external files into the table. If zero, polling will be continuous.",
                        "default": "60",
                        "value":{}
                    },
                    "text_comment_string":
                    {
                        "doc": "Specifies the character string that should be interpreted as a comment line
prefix in the source data.  All lines in the data starting with the provided string are ignored.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                        	"default": "#"
                        }
                    },
                    "text_delimiter":
                    {
                        "doc": "Specifies the character delimiting field values in the source data
and field names in the header (if present).

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                            "default": ","
                        }
                    },
                    "text_escape_character":
                    {
                        "doc": "Specifies the character that is used to escape other characters in
the source data.

An 'a', 'b', 'f', 'n', 'r', 't', or 'v' preceded by an escape character will be interpreted as the
ASCII bell, backspace, form feed, line feed, carriage return, horizontal tab, & vertical tab,
respectively.  For example, the escape character followed by an 'n' will be interpreted as a newline
within a field value.

The escape character can also be used to escape the quoting character, and will be treated as an
escape character whether it is within a quoted field value or not.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value": {}
                    },
                    "text_has_header":
                    {
                        "doc": "Indicates whether the source data contains a header row.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "true"
                        }
                    },
                    "text_header_property_delimiter":
                    {
                        "doc": "Specifies the delimiter for
{column properties}@{link /concepts/types/#column-properties} in the header row (if
present).  Cannot be set to same value as {text_delimiter}@{key of input options}.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                        	"default": "|"
                        }
                    },
                    "text_null_string":
                    {
                        "doc": "Specifies the character string that should be interpreted as a null
value in the source data.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                        	"default": ""
                        }
                    },
                    "text_quote_character":
                    {
                        "doc":"Specifies the character that should be interpreted as a field value
quoting character in the source data.  The character must appear at beginning and end of field value
to take effect.  Delimiters within quoted fields are treated as literals and not delimiters.  Within
a quoted field, two consecutive quote characters will be interpreted as a single literal quote
character, effectively escaping it.  To not have a quote character, specify an empty string.

For {delimited_text}@{choice of input.key options.file_type} {file_type}@{key of input options} only.",
                        "value":
                        {
                        	"default": "\""
                        }
                    },
                    "infer_text_delimiter":
                    {
                        "doc": "Infer the delimiter for delimited text fields and header row.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false",
                            "internal_option": true
                        }
                    },
                    "infer_text_has_header":
                    {
                        "doc": "Infer whether the text files have a header or not.",
                        "value":
                        {
                            "valid_choices":
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false",
                            "internal_option": true
                        }
                    },
                    "refresh" :
                    {
                        "doc": "Do a manual refresh of the table if it exists",
                        "value":
                        {
                            "internal_option": true,
                            "default" : "no_refresh",
                            "valid_choices" :
                            {
                                "no_refresh" :
                                {
                                    "doc": "Don't refresh",
                                    "value" : {}
                                },
                                "full_refresh" :
                                {
                                    "doc": "Always refresh even if no new records have been added.  Only refresh method guaranteed to do a full refresh (refresh all the records) if a delete or update has occurred since the last refresh.",
                                    "value" : {}
                                }
                            }
                        }
                    },
                    "truncate_table":
                    {
                        "doc": "not valid for this request, here only for consistency with insert/records/fromfiles,payload requests",
                        "value":
                        {
                            "internal_option": true,
                            "default": "false"
                        }
                    },
                    "type_id":
                    {
                        "doc": "Optional: ID of a currently registered type.",
                        "value":
                        {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "num_tasks_per_rank":
                    {
                        "doc": "Optional: number of tasks for reading file per rank. Default will be external_file_reader_num_tasks",
                        "value": {}
                    },
                    "expression":
                    {
                        "doc": "used by sql plannar, for partial loading",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "type_inference_mode" :
                    {
                        "doc": "optimize type inference for:",
                        "value":
                        {
                            "default" : "accuracy",
                            "valid_choices" :
                            {
                                "accuracy" :
                                {
                                    "doc": "scans all data to get exactly-typed & sized columns for all data present",
                                    "value" : {}
                                },
                                "speed" :
                                {
                                    "doc": "picks the widest possible column types so that 'all' values will fit with minimum data scanned",
                                    "value" : {}
                                }
                            }
                        }
                    },
                    "type_inference_num_records_per_scan":
                    {
                        "doc": "",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "type_inference_max_records_read":
                    {
                        "doc": "",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "type_inference_div_factor":
                    {
                        "doc": "",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "max_records_to_load":
                    {
                        "doc": "limit the number of records to load in this request",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "store_points_as_xy":
                    {
                        "doc": "ingest geometry objects into x,y[,z] columns, of type double, instead of into a geometry WKT/WKB type column. Only Point objects are ingested in this mode.",
                        "value": {
                            "internal_option": true,
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "store_points_as_xyz":
                    {
                        "doc": "ingest geometry objects into x,y[,z] columns, of type double, instead of into a geometry WKT/WKB type column. Only Point objects are ingested in this mode.",
                        "value": {
                            "internal_option": true,
                            "valid_choices" :
                            {
                                "true": { "doc": "", "value": {} },
                                "false": { "doc": "", "value": {} }
                            },
                            "default": "false"
                        }
                    },
                    "logical_external_table_name":
                    {
                        "doc": "Optional: Name of the source logical external table ",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "column_values_from_path":
                    {
                        "doc": "Optional: column names read from file path ",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "external_data_source_conf":
                    {
                        "doc": "",
                        "value":
                        {
                            "default": "",
                            "internal_option": true
                        }
                    },
                    "table_insert_mode":
                    {
                        "doc": "Optional: table_insert_mode. When inserting records from multiple files: if table_per_file then insert from each file into a new table. Currently supported only for shapefiles.",
                        "value": {
                            "default": "single",
                            "valid_choices" :
                            {
                                "single": { "doc": "", "value": {} },
                                "table_per_file": { "doc": "", "value": {} }
                            }
                        }
                    },
                    "layer":
                    {
                        "doc": "Optional: shapefile layer name",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "kafka_group_id":
                    {
                        "doc": "The group id to be used consuming data from a kakfa topic (valid only for kafka datasource subscriptions).",
                        "value" : {},
                        "internal_option": true
                    },
                    "kafka_type_inference_fetch_timeout":
                    {
                        "doc": "<DEVELOPER>",
                        "value": {
                            "internal_option": true,
                            "default": ""
                        }
                    },
                    "text_search_columns":
                    {
                        "doc": "Add 'text_search' property to internally inferenced string columns. Comma seperated list of column names or '*' for all columns. To add text_search property only to string columns of minimum size, set also the option 'text_search_min_column_length'",
                        "value" : {}
                    },
                    "text_search_min_column_length":
                    {
                        "doc": "Set minimum column size. Used only when 'text_search_columns' has a value.",
                        "value" : {}
                    }
                }
            }
        }
    ]
}
